import { erf } from 'mathjs';
import { Result, Bit } from '../types';
import { getCounts } from '../utils/counter';
// @ts-ignore
import FunMatrix from '@astuanax/funmatrix';
import { matrix_from_bits } from '../utils/gf2matrix';

console.log('===')
const m = [
  [1, 1, 0, 0, 0, 0],
  [1, 1, 0, 1, 0, 0],
  [1, 0, 0, 1, 0, 0],
  [1, 1, 0, 0, 1, 1],
  [0, 1, 0, 0, 0, 0],
  [0, 0, 1, 0, 0, 1],
]
console.log(FunMatrix.of(m).rank())
console.log('===')

export default (bits: Bit[], M = 32, Q = 32, alpha = 0.01): Result => {
  const n = bits.length
  const N = Math.floor(n / (M * Q)) // Number of blocks

  if (N < 38) {
    // console.log("  Number of blocks must be greater than 37")
    return [false, 0, null]
  }

  console.log("  Number of blocks %d", N)
  console.log("  Data bits used: %d", (N * M * Q))
  console.log("  Data bits discarded: %d", (n - (N * M * Q)))

  let upper1, upper2, lower;
  // Compute the reference probabilities for FM, FMM and remainder
  let r = M
  let product = 1.0
  for (let i = 0; i < r; i++) {
    // for i in range(r):
    upper1 = (1.0 - (2.0 ** (i - Q)))
    upper2 = (1.0 - (2.0 ** (i - M)))
    lower = 1 - (2.0 ** (i - r))
    product = product * ((upper1 * upper2) / lower)
  }
  const FR_prob = product * (2.0 ** ((r * (Q + M - r)) - (M * Q)))

  r = M - 1
  product = 1.0
  for (let i = 0; i < r; i++) {
    // for i in range(r):
    upper1 = (1.0 - (2.0 ** (i - Q)))
    upper2 = (1.0 - (2.0 ** (i - M)))
    lower = 1 - (2.0 ** (i - r))
    product = product * ((upper1 * upper2) / lower)
  }
  const FRM1_prob = product * (2.0 ** ((r * (Q + M - r)) - (M * Q)))

  const LR_prob = 1.0 - (FR_prob + FRM1_prob)

  let FM = 0      // Number of full rank matrices
  let FMM = 0     // Number of rank -1 matrices
  let remainder = 0
  for (let blknum = 0; blknum < N; blknum++) {
    // for blknum in range(N):
    const block = bits.slice(blknum * (M * Q), (blknum + 1) * (M * Q))
    // Put in a matrix
    const matrix = matrix_from_bits(M, Q, block)
    // Compute rank
    const rank = FunMatrix.of(matrix).rank()

    if (rank == M) // count the result
      FM += 1
    else if (rank == M - 1)
      FMM += 1
    else
      remainder += 1
  }

  let chisq = (((FM - (FR_prob * N)) ** 2) / (FR_prob * N))
  chisq += (((FMM - (FRM1_prob * N)) ** 2) / (FRM1_prob * N))
  chisq += (((remainder - (LR_prob * N)) ** 2) / (LR_prob * N))
  let p = Math.E ** (-chisq / 2.0)
  let success = (p >= alpha)

  console.log("  Full Rank Count  = ", FM)
  console.log("  Full Rank -1 Count = ", FMM)
  console.log("  Remainder Count = ", remainder)
  console.log("  Chi-Square = ", chisq)

  return [success, p, null]
}
